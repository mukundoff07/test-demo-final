{"version":3,"sources":["Connector.jsx","Toolbar.js","App.js","index.js"],"names":["Connector","getConnectorPoints","stuff","points","from","to","point","mouseX","mouseY","type","attrs","name","includes","dy","y","height","dx","x","width","angle","Math","atan2","PI","fromTextHeight","textHeight","fromTextWidth","textWidth","origin","radiusX","cos","radiusY","sin","outerRadius","toTextHeight","toTextWidth","dy1","dx1","console","log","endPoint","this","props","current","arrowEndX","arrowEndY","toSend","react_default","a","createElement","ReactKonva","strokeWidth","stroke","fill","Component","ToolBar","shadowBlur","shadowColor","Toolbar","state","arrowDraggable","previousShape","undefined","count","isDragging","_this2","Fragment","layer","Toolbar_ToolBar","draggable","ref","onDragEnd","e","ellipseName","target","rotation","appendToEllipses","refs","draggableEllipse","position","rectName","useImage","appendToRectangles","draggableRect","innerRadius","numPoints","starName","appendToStars","draggableStar","fontSize","text","fontFamily","textName","draggableText","appendToTexts","onDragStart","draggableArrow","setAttr","onDragMove","pos","getStage","getPointerPosition","shape","getIntersection","id","draw","setState","event","newArrowOnDragEnd","arrow","TransformerComponent","checkNode","stage","transformer","selectedShapeName","selectedNode","findOne","node","attachTo","detach","getLayer","batchDraw","_this","boundBoxFunc","oldBox","newBox","max","enabledAnchors","resizeEnabled","rotateEnabled","keepRatio","React","history","historyStep","Graphics","Object","classCallCheck","possibleConstructorReturn","getPrototypeOf","call","handleSave","rects","rectangles","ellipses","stars","texts","arrows","JSON","stringify","saved","arrows1","forEach","eachArrow","roadmapId","saving","fetch","method","headers","Content-Type","body","data","then","res","userId","auth","user","roadmapType","json","handleStageClick","layer2","graphicStage","newArrowRef","map","handleMouseOver","link","document","style","cursor","transform","getAbsoluteTransform","copy","invert","forceUpdate","index","indexOf","currentArrow","handleUndo","isTransforming","textEditVisible","connectors","redoing","shapeIsGone","handleRedo","length","next","returnTo","toReturn","currentShapeName","_ref","eachRect","eachEllipse","eachStar","eachText","IsJsonString","str","parse","layerX","layerY","layerScale","errMsg","currentTextRef","shouldTextUpdate","textX","textY","newArrowDropped","newConnectorDropped","lastFill","alreadyCreated","publishing","title","category","description","thumbnail","isPasteDisabled","ellipseDeleteCount","starDeleteCount","arrowDeleteCount","textDeleteCount","rectDeleteCount","handleWheel","bind","assertThisInitialized","evt","preventDefault","oldScale","scaleX","mousePointTo","newScale","deltaY","scale","prevProps","prevState","prevMainShapes","currentMainShapes","slice","toAppend","concat","push","_this3","color","gradient","getContext","createLinearGradient","addColorStop","errDisplay","className","onKeyDown","ctrlKey","keyCode","that","filter","shiftKey","copiedElement","toPush","toConsumableArray","setTimeout","tabIndex","outline","onClick","onMouseMove","onWheel","window","innerHeight","innerWidth","scaleY","onTransformStart","rect","onTransform","lastRotation","onTransformEnd","objectSpread","strokeScaleEnabled","ellipse","star","textDecoration","currentText","eachtext","onDblClick","absolutePosition","textNode","textareaWidth","textareaHeight","textareaFill","textareaFontFamily","textareaFontSize","textarea","focus","hide","src_Connector","oldPoints","shiftX","shiftY","newPoints","eachArr","App_TransformerComponent","Toolbar_Toolbar","uh","newArrow","fire","value","onChange","show","onBlur","display","top","left","overflow","border","padding","margin","resize","background","ReactDOM","render","App","getElementById"],"mappings":"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","file":"static/js/main.b97f7b4c.chunk.js","sourcesContent":["import React, { Component } from 'react'\nimport { Arrow } from 'react-konva'\nclass Connector extends Component {\n    /*******uses current position of two shapes to determine the points of an arrow\n     ******************************************************************************/\n\n    getConnectorPoints = stuff => {\n        var points = stuff.points\n        var from = stuff.from\n        var to = stuff.to\n        var mouseX = stuff.mouseX\n        var mouseY = stuff.mouseY\n        var point = { x: mouseX, y: mouseY }\n\n        if (stuff.type === 'FromAndTo') {\n            if (\n                to.attrs.name.includes('rect') &&\n                from.attrs.name.includes('rect')\n            ) {\n                //only works for rect because the calculation for origin is different for ellipse and rect\n                var dy =\n                    to.attrs.y +\n                    to.attrs.height / 2 -\n                    (from.attrs.y + from.attrs.height / 2)\n                var dx =\n                    to.attrs.x +\n                    to.attrs.width / 2 -\n                    (from.attrs.x + from.attrs.width / 2)\n                var theta = Math.atan2(dy, dx)\n                let angle = (theta / Math.PI) * 180\n\n                if (angle <= 45 && angle >= -45) {\n                    points[0] += from.attrs.width\n                    points[1] += from.attrs.height / 2\n                    points[3] += to.attrs.height / 2\n                } else if (angle > 45 && angle < 135) {\n                    points[0] += from.attrs.width / 2\n                    points[1] += from.attrs.height\n                    points[2] += to.attrs.width / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[1] += from.attrs.height / 2\n                    points[2] += to.attrs.width\n                    points[3] += to.attrs.height / 2\n                } else if (angle < -45 && angle > -135) {\n                    points[0] += from.attrs.width / 2\n                    points[3] += to.attrs.height\n                    points[2] += to.attrs.width / 2\n                }\n            } else if (\n                to.attrs.name.includes('rect') &&\n                from.attrs.name.includes('text')\n            ) {\n                //only works for rect because the calculation for origin is different for ellipse and rect\n\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\n                dy =\n                    to.attrs.y +\n                    to.attrs.height / 2 -\n                    (from.attrs.y + fromTextHeight / 2)\n                dx =\n                    to.attrs.x +\n                    to.attrs.width / 2 -\n                    (from.attrs.x + fromTextWidth / 2)\n                theta = Math.atan2(dy, dx)\n                let angle = (theta / Math.PI) * 180\n\n                if (angle <= 45 && angle >= -45) {\n                    points[0] += fromTextWidth\n                    points[1] += fromTextHeight / 2\n                    points[3] += to.attrs.height / 2\n                } else if (angle > 45 && angle < 135) {\n                    points[0] += fromTextWidth / 2\n                    points[1] += fromTextHeight\n                    points[2] += to.attrs.width / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[1] += fromTextHeight / 2\n                    points[2] += to.attrs.width\n                    points[3] += to.attrs.height / 2\n                } else if (angle < -45 && angle > -135) {\n                    points[0] += fromTextWidth / 2\n                    points[3] += to.attrs.height\n                    points[2] += to.attrs.width / 2\n                }\n            } else if (\n                to.attrs.name.includes('ellipse') &&\n                from.attrs.name.includes('ellipse')\n            ) {\n                //two ellipses\n                var origin = { x: from.attrs.x, y: from.attrs.y }\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (\n                to.attrs.name.includes('star') &&\n                from.attrs.name.includes('star')\n            ) {\n                origin = { x: from.attrs.x, y: from.attrs.y }\n                dy = points[3] - points[1]\n                dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                to.attrs.name.includes('text') &&\n                from.attrs.name.includes('text')\n            ) {\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\n                let toTextHeight = to.textHeight || to.attrs.textHeight\n                let toTextWidth = to.textWidth || to.attrs.textWidth\n                dy =\n                    to.attrs.y +\n                    toTextHeight / 2 -\n                    (from.attrs.y + fromTextHeight / 2)\n                dx =\n                    to.attrs.x +\n                    toTextWidth / 2 -\n                    (from.attrs.x + fromTextWidth / 2)\n                theta = Math.atan2(dy, dx)\n                let angle = (theta / Math.PI) * 180\n\n                if (angle <= 45 && angle >= -45) {\n                    points[0] += fromTextWidth\n                    points[1] += fromTextHeight / 2\n                    points[3] += toTextHeight / 2\n                } else if (angle > 45 && angle < 135) {\n                    points[0] += fromTextWidth / 2\n                    points[1] += fromTextHeight\n                    points[2] += toTextWidth / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[1] += fromTextHeight / 2\n                    points[2] += toTextWidth\n                    points[3] += toTextHeight / 2\n                } else if (angle < -45 && angle > -135) {\n                    points[0] += fromTextWidth / 2\n                    points[3] += toTextHeight\n                    points[2] += toTextWidth / 2\n                }\n            } else if (\n                from.attrs.name.includes('rect') &&\n                to.attrs.name.includes('ellipse')\n            ) {\n                //rect change\n                var dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\n                var dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\n\n                theta = Math.atan2(dy1, dx1)\n                var angle = (theta / Math.PI) * 180\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += from.attrs.width / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += from.attrs.width / 2\n                    points[1] += from.attrs.height\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += from.attrs.height / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += from.attrs.width\n                    points[1] += from.attrs.height / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('rect') &&\n                to.attrs.name.includes('star')\n            ) {\n                //rect change\n                dy1 = to.attrs.y + -(from.attrs.y + from.attrs.height / 2)\n                dx1 = to.attrs.x + -(from.attrs.x + from.attrs.width / 2)\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += from.attrs.width / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += from.attrs.width / 2\n                    points[1] += from.attrs.height\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += from.attrs.height / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += from.attrs.width\n                    points[1] += from.attrs.height / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('rect') &&\n                to.attrs.name.includes('text')\n            ) {\n                //only works for rect because the calculation for origin is different for ellipse and rect\n                let toTextHeight = to.textHeight || to.attrs.textHeight\n                let toTextWidth = to.textWidth || to.attrs.textWidth\n                console.log(to)\n                dy =\n                    to.attrs.y +\n                    toTextHeight / 2 -\n                    (from.attrs.y + from.attrs.height / 2)\n                dx =\n                    to.attrs.x +\n                    toTextWidth / 2 -\n                    (from.attrs.x + from.attrs.width / 2)\n                var theta = Math.atan2(dy, dx)\n                let angle = (theta / Math.PI) * 180\n\n                /*  console.log(\n                    'from rect and to text',\n                    'angle: ',\n                    angle,\n                    'from',\n                    from,\n                    'to',\n                    to\n                )*/\n\n                if (angle <= 45 && angle >= -45) {\n                    points[0] += from.attrs.width\n                    points[1] += from.attrs.height / 2\n                    points[3] += toTextHeight / 2\n                } else if (angle > 45 && angle < 135) {\n                    points[0] += from.attrs.width / 2\n                    points[1] += from.attrs.height\n                    points[2] += toTextWidth / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[1] += from.attrs.height / 2\n                    points[2] += toTextWidth\n                    points[3] += toTextHeight / 2\n                } else if (angle < -45 && angle > -135) {\n                    points[0] += from.attrs.width / 2\n                    points[3] += toTextHeight\n                    points[2] += toTextWidth / 2\n                }\n            } else if (\n                from.attrs.name.includes('ellipse') &&\n                to.attrs.name.includes('rect')\n            ) {\n                //rect change\n                dy1 = to.attrs.y + to.attrs.height / 2 - from.attrs.y\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[2] += to.attrs.width / 2\n                    points[3] += to.attrs.height\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[2] += to.attrs.width / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[2] += to.attrs.width\n                    points[3] += to.attrs.height / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[3] += to.attrs.height / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('ellipse') &&\n                to.attrs.name.includes('text')\n            ) {\n                let toTextHeight = to.textHeight || to.attrs.textHeight\n                let toTextWidth = to.textWidth || to.attrs.textWidth\n                //rect change\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[2] += toTextWidth / 2\n                    points[3] += toTextHeight\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[2] += toTextWidth / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[2] += toTextWidth\n                    points[3] += toTextHeight / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[3] += toTextHeight / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[0] -= from.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\n\n                console.log(\n                    'new points',\n                    points,\n                    'from',\n                    from,\n                    'from coord',\n                    from.attrs\n                )\n            } else if (\n                from.attrs.name.includes('ellipse') &&\n                to.attrs.name.includes('star')\n            ) {\n                //two ellipses\n                origin = { x: from.attrs.x, y: from.attrs.y }\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('star') &&\n                to.attrs.name.includes('ellipse')\n            ) {\n                //two ellipses\n                origin = { x: from.attrs.x, y: from.attrs.y }\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('star') &&\n                to.attrs.name.includes('rect')\n            ) {\n                //two ellipses\n                dy1 = to.attrs.y + to.attrs.width / 2 - from.attrs.y\n                dx1 = to.attrs.x + to.attrs.width / 2 - from.attrs.x\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[2] += to.attrs.width / 2\n                    points[3] += to.attrs.height\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[2] += to.attrs.width / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[2] += to.attrs.width\n                    points[3] += to.attrs.height / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[3] += to.attrs.width / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('star') &&\n                to.attrs.name.includes('text')\n            ) {\n                let toTextHeight = to.textHeight || to.attrs.textHeight\n                let toTextWidth = to.textWidth || to.attrs.textWidth\n                //two ellipses\n                dy1 = to.attrs.y + toTextHeight / 2 - from.attrs.y\n                dx1 = to.attrs.x + toTextWidth / 2 - from.attrs.x\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[2] += toTextWidth / 2\n                    points[3] += toTextHeight\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[2] += toTextWidth / 2\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[2] += toTextWidth\n                    points[3] += toTextHeight / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[3] += toTextHeight / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[0] -= from.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('text') &&\n                to.attrs.name.includes('star')\n            ) {\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\n                //rect change\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += fromTextWidth / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += fromTextWidth / 2\n                    points[1] += fromTextHeight\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += fromTextHeight / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += fromTextWidth\n                    points[1] += fromTextHeight / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (\n                from.attrs.name.includes('text') &&\n                to.attrs.name.includes('ellipse')\n            ) {\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\n                //rect change\n                dy1 = to.attrs.y + -(from.attrs.y + fromTextHeight / 2)\n                dx1 = to.attrs.x + -(from.attrs.x + fromTextWidth / 2)\n\n                theta = Math.atan2(dy1, dx1)\n                angle = (theta / Math.PI) * 180\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += fromTextWidth / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += fromTextWidth / 2\n                    points[1] += fromTextHeight\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += fromTextHeight / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += fromTextWidth\n                    points[1] += fromTextHeight / 2\n                }\n                //ellipse change\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\n            }\n        }\n\n        if (stuff.type === 'onlyFrom') {\n            if (from.attrs.name.includes('rect')) {\n                origin = {\n                    x: from.attrs.x + from.attrs.width / 2,\n                    y: from.attrs.y + from.attrs.height / 2\n                }\n                dy = point.y - origin.y\n                dx = point.x - origin.x\n                theta = Math.atan2(dy, dx)\n                angle = (theta / Math.PI) * 180\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += from.attrs.width / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += from.attrs.width / 2\n                    points[1] += from.attrs.height\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += from.attrs.height / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += from.attrs.width\n                    points[1] += from.attrs.height / 2\n                }\n            } else if (from.attrs.name.includes('ellipse')) {\n                origin = {\n                    x: from.attrs.x,\n                    y: from.attrs.y\n                }\n\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n\n                //  console.log(\"we messing with a ellipse\", points, angle, from);\n\n                points[0] += -from.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (from.attrs.name.includes('star')) {\n                origin = { x: from.attrs.x, y: from.attrs.y }\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n\n                //  console.log(\"we messing with a ellipse\", points, angle, from);\n\n                points[0] += -from.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[1] += from.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (from.attrs.name.includes('text')) {\n                let fromTextHeight = from.textHeight || from.attrs.textHeight\n                let fromTextWidth = from.textWidth || from.attrs.textWidth\n\n                origin = {\n                    x: from.attrs.x + fromTextWidth / 2,\n                    y: from.attrs.y + fromTextWidth / 2\n                }\n                dy = point.y - origin.y\n                dx = point.x - origin.x\n                theta = Math.atan2(dy, dx)\n                angle = (theta / Math.PI) * 180\n\n                if (angle <= -45 && angle >= -135) {\n                    //top\n                    points[0] += fromTextWidth / 2\n                } else if (angle > 45 && angle < 135) {\n                    //bottom\n                    points[0] += fromTextWidth / 2\n                    points[1] += fromTextHeight\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    //left\n                    points[1] += fromTextHeight / 2\n                } else if (angle > -45 && angle < 45) {\n                    points[0] += fromTextWidth\n                    points[1] += fromTextHeight / 2\n                }\n            }\n        }\n        if (stuff.type === 'onlyTo') {\n            if (to.attrs.name.includes('rect')) {\n                var endPoint = { x: points[0], y: points[1] }\n                origin = {\n                    x: to.attrs.x + to.attrs.width / 2,\n                    y: to.attrs.y + to.attrs.height / 2\n                }\n\n                dy = endPoint.y - origin.y\n                dx = endPoint.x - origin.x\n                theta = Math.atan2(dy, dx)\n                angle = (theta / Math.PI) * 180\n\n                if (angle > 45 && angle < 135) {\n                    points[2] += to.attrs.width / 2\n                    points[3] += to.attrs.height\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[3] += to.attrs.height / 2\n                } else if (angle > -135 && angle < -45) {\n                    points[2] += to.attrs.width / 2\n                } else {\n                    points[2] += to.attrs.width\n                    points[3] += to.attrs.height / 2\n                }\n            } else if (to.attrs.name.includes('ellipse')) {\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.radiusX * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.radiusY * Math.sin(angle + Math.PI)\n            } else if (to.attrs.name.includes('star')) {\n                const dy = points[3] - points[1]\n                const dx = points[2] - points[0]\n                let angle = Math.atan2(-dy, dx)\n                //      console.log(dy, dx);\n\n                points[2] += to.attrs.outerRadius * Math.cos(angle + Math.PI)\n                points[3] -= to.attrs.outerRadius * Math.sin(angle + Math.PI)\n            } else if (to.attrs.name.includes('text')) {\n                let toTextHeight = to.textHeight || to.attrs.textHeight\n                let toTextWidth = to.textWidth || to.attrs.textWidth\n\n                endPoint = { x: points[0], y: points[1] }\n                origin = {\n                    x: to.attrs.x + toTextWidth / 2,\n                    y: to.attrs.y + toTextWidth / 2\n                }\n\n                dy = endPoint.y - origin.y\n                dx = endPoint.x - origin.x\n                theta = Math.atan2(dy, dx)\n                angle = (theta / Math.PI) * 180\n\n                if (angle > 45 && angle < 135) {\n                    points[2] += toTextWidth / 2\n                    points[3] += toTextHeight\n                } else if (\n                    (angle > 135 && angle < 180) ||\n                    (angle > -180 && angle < -135)\n                ) {\n                    points[3] += toTextHeight / 2\n                } else if (angle > -135 && angle < -45) {\n                    points[2] += toTextWidth / 2\n                } else {\n                    points[2] += toTextHeight\n                    points[3] += toTextHeight / 2\n                }\n            }\n        }\n\n        return points\n    }\n\n    render() {\n        var points = null\n\n        if (this.props.current) {\n            if (this.props.from) {\n                points = [\n                    this.props.from.attrs.x,\n                    this.props.from.attrs.y,\n                    this.props.arrowEndX,\n                    this.props.arrowEndY\n                ]\n                let stuff = {\n                    points: points,\n                    from: this.props.from,\n                    mouseX: this.props.arrowEndX,\n                    mouseY: this.props.arrowEndY,\n                    type: 'onlyFrom'\n                }\n                points = this.getConnectorPoints(stuff)\n            }\n        }\n        if (this.props.current === false) {\n            if (this.props.from && this.props.to) {\n                points = [\n                    this.props.from.attrs.x,\n                    this.props.from.attrs.y,\n                    this.props.to.attrs.x,\n                    this.props.to.attrs.y\n                ]\n\n                let toSend = {\n                    points: points,\n                    from: this.props.from,\n                    to: this.props.to,\n                    type: 'FromAndTo'\n                }\n\n                points = this.getConnectorPoints(toSend)\n\n                //get connector points\n            } else if (this.props.from) {\n                points = [\n                    this.props.from.attrs.x,\n                    this.props.from.attrs.y,\n                    this.props.points[2],\n                    this.props.points[3]\n                ]\n\n                let stuff = {\n                    points: points,\n                    from: this.props.from,\n                    mouseX: this.props.points[2],\n                    mouseY: this.props.points[3],\n                    type: 'onlyFrom'\n                }\n                points = this.getConnectorPoints(stuff)\n            } else if (this.props.to) {\n                points = [\n                    this.props.points[0],\n                    this.props.points[1],\n                    this.props.to.attrs.x,\n                    this.props.to.attrs.y\n                ]\n\n                let stuff = {\n                    points: points,\n                    to: this.props.to,\n                    type: 'onlyTo',\n                    mouseX: this.props.to.attrs.x,\n                    mouseY: this.props.to.attrs.y\n                }\n                points = this.getConnectorPoints(stuff)\n            }\n        }\n        return (\n            <Arrow\n                name={this.props.name}\n                points={points}\n                strokeWidth={1.5}\n                stroke={this.props.stroke}\n                fill={this.props.fill}\n            />\n        )\n    }\n}\n\nexport default Connector\n","import React, { Component } from 'react'\n\nimport { Rect, Ellipse, Star, Text, Arrow } from 'react-konva'\n//at start, two same rectangles at one place\n//at the end of drag, note the x and y of the dragged rectangle, append it to GraphicsMain\n//return the dragged rectangle to original\n\nconst ToolBar = () => (\n    <Rect\n        y={80}\n        width={77.5}\n        height={355}\n        fill=\"white\"\n        shadowBlur={5}\n        shadowColor=\"black\"\n    />\n)\n\nexport default class Toolbar extends Component {\n    state = {\n        arrowDraggable: false,\n        previousShape: undefined,\n        count: 0,\n        isDragging: false\n    }\n    render() {\n        return (\n            <React.Fragment>\n                {this.props.layer ? (\n                    <React.Fragment>\n                        <ToolBar />\n                        <Ellipse\n                            radiusX={20}\n                            radiusY={20}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={37.5}\n                            y={125}\n                        />\n                        <Ellipse\n                            radiusX={20}\n                            radiusY={20}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={37.5}\n                            y={125}\n                            draggable\n                            ref=\"draggableEllipse\"\n                            onDragEnd={e => {\n                                //add the rectangle to parent\n                                let name = 'ellipse' + this.props.ellipseName\n                                let toSend = {\n                                    x: e.target.x(),\n                                    y: e.target.y(),\n                                    radiusX: 20,\n                                    radiusY: 20,\n                                    stroke: 'black',\n                                    strokeWidth: 1.5,\n                                    name: name,\n                                    fill: 'white',\n                                    ref: name,\n                                    rotation: 0\n                                }\n                                this.props.appendToEllipses(toSend)\n\n                                var ellipse = this.refs.draggableEllipse\n\n                                ellipse.position({\n                                    x: 37.5,\n                                    y: 125\n                                })\n                            }}\n                        />\n                        <Rect\n                            width={35}\n                            height={35}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={20}\n                            y={180}\n                            fill=\"white\"\n                        />\n                        <Rect\n                            width={35}\n                            height={35}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={20}\n                            y={180}\n                            draggable\n                            fill=\"white\"\n                            ref=\"draggableRect\"\n                            onDragEnd={e => {\n                                //add the rectangle to parent\n                                let name = 'rectangle' + this.props.rectName\n                                let toSend = {\n                                    x: e.target.x(),\n                                    y: e.target.y(),\n                                    width: 35,\n                                    height: 35,\n                                    stroke: 'black',\n                                    strokeWidth: 1.5,\n                                    rotation: 0,\n                                    name: name,\n                                    ref: name,\n                                    fill: 'white',\n                                    useImage: false\n                                }\n                                this.props.appendToRectangles(toSend)\n\n                                var rect = this.refs.draggableRect\n\n                                rect.position({\n                                    x: 20,\n                                    y: 180\n                                })\n                            }}\n                        />\n                        <Star\n                            innerRadius={8}\n                            outerRadius={20}\n                            numPoints={5}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={37.5}\n                            y={270}\n                            fill=\"white\"\n                        />\n                        <Star\n                            innerRadius={8}\n                            outerRadius={20}\n                            numPoints={5}\n                            stroke=\"black\"\n                            strokeWidth={1.5}\n                            x={37.5}\n                            y={270}\n                            draggable\n                            ref=\"draggableStar\"\n                            onDragEnd={e => {\n                                //add the rectangle to parent\n                                let name = 'star' + this.props.starName\n                                let toSend = {\n                                    x: e.target.x(),\n                                    y: e.target.y(),\n                                    innerRadius: 8,\n                                    outerRadius: 20,\n                                    numPoints: 5,\n                                    stroke: 'black',\n                                    strokeWidth: 1.5,\n                                    name: name,\n                                    fill: 'white',\n                                    ref: name,\n                                    rotation: 0\n                                }\n                                this.props.appendToStars(toSend)\n\n                                var star = this.refs.draggableStar\n\n                                star.position({\n                                    x: 37.5,\n                                    y: 270\n                                })\n                            }}\n                        />\n                        <Text\n                            fontSize={40}\n                            text=\"T\"\n                            fontFamily=\"Belgrano\"\n                            x={24}\n                            y={320}\n                        />\n                        <Text\n                            fontSize={40}\n                            text=\"T\"\n                            fontFamily=\"Belgrano\"\n                            x={24}\n                            y={320}\n                            draggable\n                            ref=\"draggableText\"\n                            onDragEnd={e => {\n                                //add the rectangle to parent\n                                let name = 'text' + this.props.textName\n                                let ref = 'text' + this.props.textName\n                                let toSend = {\n                                    x: e.target.x(),\n                                    y: e.target.y(),\n                                    fontSize: 25,\n                                    fontFamily: 'Belgrano',\n                                    ref: ref,\n                                    name: name,\n                                    text: '',\n                                    fill: 'black',\n                                    width: 300,\n                                    height: 25,\n                                    rotation: 0,\n                                    textWidth: this.refs.draggableText\n                                        .textWidth,\n                                    textHeight: this.refs.draggableText\n                                        .textHeight\n                                }\n                                console.log('tosend', toSend)\n                                this.props.appendToTexts(toSend)\n\n                                var text = this.refs.draggableText\n\n                                text.position({\n                                    x: 24,\n                                    y: 320\n                                })\n                            }}\n                        />\n                        <Arrow\n                            points={[20, 400, 50, 400]}\n                            fill=\"black\"\n                            stroke=\"black\"\n                        />\n                        <Arrow\n                            points={[20, 400, 50, 400]}\n                            fill=\"black\"\n                            stroke=\"black\"\n                            ref=\"draggableArrow\"\n                            name=\"draggableArrow\"\n                            draggable\n                            onDragStart={() => {\n                                this.refs.draggableArrow.setAttr('fill', 'grey')\n                                this.refs.draggableArrow.setAttr(\n                                    'stroke',\n                                    'grey'\n                                )\n                            }}\n                            onDragMove={() => {\n                                var pos = this.props.layer\n                                    .getStage()\n                                    .getPointerPosition()\n                                var shape = this.props.layer.getIntersection(\n                                    pos\n                                )\n\n                                //after first frame\n                                if (\n                                    this.state.previousShape !== undefined &&\n                                    this.state.previousShape !== null\n                                )\n                                    if (this.state.previousShape !== shape) {\n                                        //arrow entered a new shape\n\n                                        //the shape we left gets its original color back\n                                        if (\n                                            this.state.previousShape.attrs\n                                                .id !== 'ContainerRect' &&\n                                            !this.state.previousShape.attrs.name.includes(\n                                                'arrow'\n                                            )\n                                        ) {\n                                            this.refs.draggableArrow.setAttr(\n                                                'fill',\n                                                'black'\n                                            )\n                                            this.refs.draggableArrow.setAttr(\n                                                'stroke',\n                                                'black'\n                                            )\n                                        }\n                                    }\n                                    //if arrow is moving in a single shape\n                                    else if (\n                                        this.state.previousShape.attrs.id !==\n                                            'ContainerRect' &&\n                                        !shape.attrs.name.includes('arrow')\n                                    ) {\n                                        //if it the first time the shapes are same, set shape to blue, store the original color\n                                        this.refs.draggableArrow.setAttr(\n                                            'fill',\n                                            '#ccf5ff'\n                                        )\n                                        this.refs.draggableArrow.setAttr(\n                                            'stroke',\n                                            '#ccf5ff'\n                                        )\n                                    }\n\n                                this.props.layer.draw()\n\n                                this.setState({ previousShape: shape })\n                            }}\n                            onDragEnd={event => {\n                                var pos = this.props.layer\n                                    .getStage()\n                                    .getPointerPosition()\n                                var shape = this.props.layer.getIntersection(\n                                    pos\n                                )\n\n                                //shape is not containerRect, which means we are on a shape\n                                if (\n                                    shape &&\n                                    shape.attrs.id === undefined &&\n                                    !shape.attrs.name.includes('arrow')\n                                ) {\n                                    let toSend = {\n                                        x: pos.x,\n                                        y: pos.y,\n                                        points: [20, 475, 60, 475],\n                                        from: shape,\n                                        stroke: 'black',\n                                        strokeWidth: '1.5',\n                                        fill: 'black'\n                                    }\n                                    console.log('from shape', shape)\n                                    this.props.newArrowOnDragEnd(toSend)\n                                } else {\n                                    let toSend = {\n                                        x: pos.x,\n                                        y: pos.y,\n                                        points: [20, 475, 60, 475],\n                                        stroke: 'black',\n                                        strokeWidth: '1.5',\n                                        fill: 'black'\n                                    }\n\n                                    this.props.newArrowOnDragEnd(toSend)\n                                }\n\n                                //if shape is not arrow nor the containerRect then we make a connector instead\n\n                                //onDragEnd = dropping arrow down, create a new arrow with 2 same points at the dropped location\n                                //create new arrow in Graphics.js\n                                //from there, fire onMouseMove over the entire stage\n                                //the arrow's points should be the first point onDragEnd and the second should be the current\n                                //mouse position determined by onMouseMove event in stage\n                                var arrow = this.refs.draggableArrow\n                                arrow.position({ x: 0, y: 0 })\n                                arrow.setAttr('fill', 'black')\n                                arrow.setAttr('stroke', 'black')\n\n                                arrow.draw()\n                            }}\n                        />\n                    </React.Fragment>\n                ) : null}\n            </React.Fragment>\n        )\n    }\n}\n","//todo: allow for picture inside of rect/ellipse/stfar\n//todo: connect using arrow\n//todo: for rightToolBar, show fontSize,fontFamily for text for the rest allow to add pictures\n//todo: zoomable\nimport React, { Component } from \"react\";\n\nimport {\n  Stage,\n  Layer,\n  Rect,\n  Transformer,\n  Ellipse,\n  Star,\n  Text,\n  Arrow\n} from \"react-konva\";\nimport Connector from \"./Connector.jsx\";\nimport Toolbar from \"./Toolbar.js\";\n\nimport \"./Graphics.css\";\n\nclass TransformerComponent extends React.Component {\n  componentDidMount() {\n    this.checkNode();\n  }\n  componentDidUpdate() {\n    this.checkNode();\n  }\n  checkNode() {\n    const stage = this.transformer.getStage();\n\n    const { selectedShapeName } = this.props;\n    if (selectedShapeName === \"\") {\n      this.transformer.detach();\n      return;\n    }\n    const selectedNode = stage.findOne(\".\" + selectedShapeName);\n    if (selectedNode === this.transformer.node()) {\n      return;\n    }\n\n    if (selectedNode) {\n      this.transformer.attachTo(selectedNode);\n    } else {\n      this.transformer.detach();\n    }\n    this.transformer.getLayer().batchDraw();\n  }\n  render() {\n    if (this.props.selectedShapeName.includes(\"text\")) {\n      var stuff = (\n        <Transformer\n          ref={node => {\n            this.transformer = node;\n          }}\n          name=\"transformer\"\n          boundBoxFunc={(oldBox, newBox) => {\n            newBox.width = Math.max(30, newBox.width);\n            return newBox;\n          }}\n          enabledAnchors={[\"middle-left\", \"middle-right\"]}\n        />\n      );\n    } else if (this.props.selectedShapeName.includes(\"star\")) {\n      var stuff = (\n        <Transformer\n          ref={node => {\n            this.transformer = node;\n          }}\n          name=\"transformer\"\n          enabledAnchors={[\n            \"top-left\",\n            \"top-right\",\n            \"bottom-left\",\n            \"bottom-right\"\n          ]}\n        />\n      );\n    } else if (this.props.selectedShapeName.includes(\"arrow\")) {\n      var stuff = (\n        <Transformer\n          ref={node => {\n            this.transformer = node;\n          }}\n          name=\"transformer\"\n          resizeEnabled={false}\n          rotateEnabled={false}\n        />\n      );\n    } else {\n      var stuff = (\n        <Transformer\n          ref={node => {\n            this.transformer = node;\n          }}\n          name=\"transformer\"\n          keepRatio={true}\n        />\n      );\n    }\n    return stuff;\n  }\n}\n\nvar history = [];\nvar historyStep = 0;\n\nclass Graphics extends Component {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      layerX: 0,\n      layerY: 0,\n      layerScale: 1,\n      selectedShapeName: \"\",\n      errMsg: \"\",\n      rectangles: [],\n      ellipses: [],\n      stars: [],\n      texts: [],\n      arrows: [],\n      connectors: [],\n      currentTextRef: \"\",\n      shouldTextUpdate: true,\n      textX: 0,\n      textY: 0,\n      textEditVisible: false,\n      arrowDraggable: false,\n      newArrowRef: \"\",\n      count: 0,\n      newArrowDropped: false,\n      newConnectorDropped: false,\n      arrowEndX: 0,\n      arrowEndY: 0,\n      isTransforming: false,\n      lastFill: null,\n\n      saving: null,\n      saved: [],\n      roadmapId: null,\n      alreadyCreated: false,\n      publishing: false,\n      title: \"\",\n      category: \"\",\n      description: \"\",\n      thumbnail: \"\",\n      isPasteDisabled: false,\n      ellipseDeleteCount: 0,\n      starDeleteCount: 0,\n      arrowDeleteCount: 0,\n      textDeleteCount: 0,\n      rectDeleteCount: 0\n    };\n\n    this.handleWheel = this.handleWheel.bind(this);\n\n  }\n\n  handleSave = () => {\n    const rects = this.state.rectangles,\n      ellipses = this.state.ellipses,\n      stars = this.state.stars,\n      texts = this.state.texts,\n      arrows = this.state.arrows;\n    if (\n      JSON.stringify(this.state.saved) !==\n      JSON.stringify([rects, ellipses, stars, texts, arrows])\n    ) {\n      this.setState({ saved: [rects, ellipses, stars, texts, arrows] });\n\n      let arrows1 = this.state.arrows;\n      arrows1.forEach(eachArrow => {\n        //for \"from & to of each arrow\"\n        if (eachArrow.from && eachArrow.from.attrs) {\n          if (eachArrow.from.attrs.name.includes(\"text\")) {\n            eachArrow.from.textWidth = eachArrow.from.textWidth;\n\n            eachArrow.from.textHeight = eachArrow.from.textHeight;\n          }\n        }\n        if (eachArrow.to && eachArrow.to.attrs) {\n          if (eachArrow.to.attrs.name.includes(\"text\")) {\n            eachArrow.to.attrs.textWidth = eachArrow.to.textWidth;\n            eachArrow.to.attrs.textHeight = eachArrow.to.textHeight;\n          }\n        }\n      });\n\n      if (this.state.roadmapId) {\n        //if draft already exists\n        this.setState({ saving: true });\n        fetch(\"/api/roadmap/modifyDraftDB\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            roadmapId: this.state.roadmapId,\n\n            data: {\n              rects: rects,\n              ellipses: ellipses,\n              stars: stars,\n              texts: texts,\n              arrows: arrows1\n            }\n          })\n        }).then(res => {\n          this.setState({ saving: false });\n        });\n      } else {\n        //if first time pressing sav\n        this.setState({ saving: true });\n        fetch(\"/api/roadmap/saveRoadmapToDB\", {\n          method: \"POST\",\n          headers: { \"Content-Type\": \"application/json\" },\n          body: JSON.stringify({\n            userId: this.props.auth.user.id,\n            roadmapType: \"draft\",\n            data: {\n              rects: rects,\n              ellipses: ellipses,\n              stars: stars,\n              texts: texts,\n              arrows: arrows\n            }\n          })\n        }).then(res =>\n          res.json().then(data => {\n            this.setState({ saving: false });\n            this.setState({ roadmapId: data.roadmapId });\n          })\n        );\n      }\n    }\n  };\n\n  handleStageClick = e => {\n    var pos = this.refs.layer2.getStage().getPointerPosition();\n    var shape = this.refs.layer2.getIntersection(pos);\n\n    console.log(\"texts\", this.state.texts);\n\n    if (\n      shape !== null &&\n      shape.name() !== undefined &&\n      shape !== undefined &&\n      shape.name() !== undefined\n    ) {\n      this.setState(\n        {\n          selectedShapeName: shape.name()\n        },\n        () => {\n          this.refs.graphicStage.draw();\n        }\n      );\n    }\n\n    //arrow logic\n    if (this.state.newArrowRef !== \"\") {\n      if (this.state.previousShape) {\n        if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\n          //console.log(this.refs.graphicStage.findOne(\".\" + this.state.newArrowRef));\n          //\n\n          this.state.arrows.map(eachArrow => {\n            if (eachArrow.name === this.state.newArrowRef) {\n              eachArrow.to = this.state.previousShape;\n            }\n          });\n\n          //console.log(newConnector, this.state.newArrowRef);\n          //newConnector.setAttr(\"to\", this.state.previousShape);\n          //console.log(newConnector);\n        }\n      }\n\n      //handle connector more\n      //if the currentArrow ref has a from, and that e.target.attrs.id isn't containerRect,\n      //then find the current shape with stage find name and then yeah\n      this.state.arrows.map(eachArrow => {\n        if (eachArrow.name === this.state.newArrowRef) {\n          eachArrow.fill = \"black\";\n          eachArrow.stroke = \"black\";\n        }\n      });\n      //arrow logic, there's e.evt.pageX, pageY\n      this.setState({\n        arrowDraggable: false,\n        newArrowRef: \"\"\n      });\n    }\n  };\n  handleMouseOver = event => {\n    //get the currennt arrow ref and modify its position by filtering & pushing again\n    //console.log(\"lastFill: \", this.state.lastFill);\n    var pos = this.refs.graphicStage.getPointerPosition();\n    var shape = this.refs.graphicStage.getIntersection(pos);\n\n    if (shape && shape.attrs.link) {\n      document.body.style.cursor = \"pointer\";\n    } else {\n      document.body.style.cursor = \"default\";\n    }\n\n    //if we are moving an arrow\n    if (this.state.newArrowRef !== \"\") {\n      //filling color logic:\n\n      var transform = this.refs.layer2.getAbsoluteTransform().copy();\n      transform.invert();\n\n      pos = transform.point(pos);\n      this.setState({ arrowEndX: pos.x, arrowEndY: pos.y });\n      //last non arrow object\n      if (shape && shape.attrs && shape.attrs.name != undefined) {\n        //  console.log(shape);\n        if (!shape.attrs.name.includes(\"arrow\")) {\n          //after first frame\n          if (this.state.previousShape)\n            if (this.state.previousShape !== shape) {\n              //arrow entered a new shape\n\n              //set current arrow to blue\n              if (this.state.previousShape.attrs.id !== \"ContainerRect\") {\n                this.state.arrows.map(eachArrow => {\n                  if (eachArrow.name === this.state.newArrowRef) {\n                    eachArrow.fill = \"black\";\n                    eachArrow.stroke = \"black\";\n                  }\n                });\n                this.forceUpdate();\n              } else {\n                this.state.arrows.map(eachArrow => {\n                  if (eachArrow.name === this.state.newArrowRef) {\n                    eachArrow.fill = \"#ccf5ff\";\n                    eachArrow.stroke = \"#ccf5ff\";\n                  }\n                });\n                this.forceUpdate();\n              }\n            }\n          //if arrow is moving in a single shape\n        }\n\n        if (!shape.attrs.name.includes(\"arrow\")) {\n          this.setState({ previousShape: shape });\n        }\n      }\n    }\n    var arrows = this.state.arrows;\n\n    arrows.map(eachArrow => {\n      if (eachArrow.name === this.state.newArrowRef) {\n        var index = arrows.indexOf(eachArrow);\n        let currentArrow = eachArrow;\n        currentArrow.points = [\n          currentArrow.points[0],\n          currentArrow.points[1],\n          pos.x,\n          pos.y\n          /*  event.evt.pageY -\n            document.getElementById(\"NavBar\").getBoundingClientRect().height */\n        ];\n\n        this.state.arrows[index] = currentArrow;\n      }\n    });\n  };\n  handleWheel(event) {\n    if (\n      this.state.rectangles.length === 0 &&\n      this.state.ellipses.length === 0 &&\n      this.state.stars.length === 0 &&\n      this.state.texts.length === 0 &&\n      this.state.arrows.length === 0\n    ) {\n    } else {\n      event.evt.preventDefault();\n      const scaleBy = 1.2;\n      const stage = this.refs.graphicStage;\n      const layer = this.refs.layer2;\n      const oldScale = layer.scaleX();\n      const mousePointTo = {\n        x:\n          stage.getPointerPosition().x / oldScale -\n          this.state.layerX / oldScale,\n        y:\n          stage.getPointerPosition().y / oldScale - this.state.layerY / oldScale\n      };\n\n      const newScale =\n        event.evt.deltaY < 0 ? oldScale * scaleBy : oldScale / scaleBy;\n\n      layer.scale({ x: newScale, y: newScale });\n\n      /*  console.log(\n        oldScale,\n        mousePointTo,\n        stage.getPointerPosition().x,\n        stage.getPointerPosition().y\n      );\n    */\n      this.setState({\n        layerScale: newScale,\n        layerX:\n          -(mousePointTo.x - stage.getPointerPosition().x / newScale) *\n          newScale,\n        layerY:\n          -(mousePointTo.y - stage.getPointerPosition().y / newScale) * newScale\n      });\n    }\n  }\n  componentDidUpdate(prevProps, prevState) {\n    let prevMainShapes = [\n      prevState.rectangles,\n      prevState.ellipses,\n      prevState.stars,\n      prevState.arrows,\n      prevState.connectors,\n      prevState.texts\n    ];\n    let currentMainShapes = [\n      this.state.rectangles,\n      this.state.ellipses,\n      this.state.stars,\n      this.state.arrows,\n      this.state.connectors,\n      this.state.texts\n    ];\n\n    if (!this.state.redoing && !this.state.isTransforming)\n      if (JSON.stringify(this.state) !== JSON.stringify(prevState)) {\n        if (\n          JSON.stringify(prevMainShapes) !== JSON.stringify(currentMainShapes)\n        ) {\n          //if text shouldn't update, don't append to  history\n          if (this.state.shouldTextUpdate) {\n            var uh = history;\n            history = uh.slice(0, historyStep + 1);\n            //console.log(\"sliced\", history);\n            var toAppend = this.state;\n            history = history.concat(toAppend);\n            //console.log(\"new\", history);\n            historyStep += 1;\n            //console.log(history, historyStep, history[historyStep]);\n          }\n        }\n      } else {\n        //console.log(\"compoenntDidUpdate but attrs didn't change\");\n      }\n    this.state.redoing = false;\n  }\n\n  handleUndo = () => {\n    if (!this.state.isTransforming) {\n      if (!this.state.textEditVisible) {\n        if (historyStep === 0) {\n          return;\n        }\n        historyStep -= 1;\n\n        this.setState(\n          {\n            rectangles: history[historyStep].rectangles,\n            arrows: history[historyStep].arrows,\n            ellipses: history[historyStep].ellipses,\n            stars: history[historyStep].stars,\n            texts: history[historyStep].texts,\n            connectors: history[historyStep].connectors,\n            redoing: true,\n            selectedShapeName: this.shapeIsGone(history[historyStep])\n              ? \"\"\n              : this.state.selectedShapeName\n          },\n          () => {\n            this.refs.graphicStage.draw();\n          }\n        );\n      }\n    }\n  };\n\n  handleRedo = () => {\n    if (historyStep === history.length - 1) {\n      return;\n    }\n    historyStep += 1;\n    const next = history[historyStep];\n    this.setState(\n      {\n        rectangles: next.rectangles,\n        arrows: next.arrows,\n        ellipses: next.ellipses,\n        stars: next.stars,\n        texts: next.texts,\n        redoing: true,\n        selectedShapeName: this.shapeIsGone(history[historyStep])\n          ? \"\"\n          : this.state.selectedShapeName\n      },\n      () => {\n        this.forceUpdate();\n      }\n    );\n  };\n\n  shapeIsGone = returnTo => {\n    var toReturn = true;\n    let currentShapeName = this.state.selectedShapeName;\n    let [rectangles, ellipses, stars, arrows, texts] = [\n      returnTo.rectangles,\n      returnTo.ellipses,\n      returnTo.stars,\n      returnTo.arrows,\n\n      returnTo.texts\n    ];\n    rectangles.map(eachRect => {\n      if (eachRect.name === currentShapeName) {\n        toReturn = false;\n      }\n    });\n    ellipses.map(eachEllipse => {\n      if (eachEllipse.name === currentShapeName) {\n        toReturn = false;\n      }\n    });\n    stars.map(eachStar => {\n      if (eachStar.name === currentShapeName) {\n        toReturn = false;\n      }\n    });\n    arrows.map(eachArrow => {\n      if (eachArrow.name === currentShapeName) {\n        toReturn = false;\n      }\n    });\n\n    texts.map(eachText => {\n      if (eachText.name === currentShapeName) {\n        toReturn = false;\n      }\n    });\n\n    return toReturn;\n  };\n  IsJsonString = str => {\n    try {\n      JSON.parse(str);\n    } catch (e) {\n      return false;\n    }\n    return true;\n  };\n\n  async componentDidMount() {\n    history.push(this.state);\n    this.setState({ selectedShapeName: \"\" });\n\n\n\n    //if draft\n\n  }\n\n  render() {\n    let saveText;\n\n    let saving = this.state.saving;\n    if (saving !== null) {\n      if (saving) {\n        saveText = <div style={{ color: \"white\" }}>Saving</div>;\n      } else {\n        saveText = <div style={{ color: \"white\" }}>Saved</div>;\n      }\n    }\n\n    const canvas = document.createElement(\"canvas\");\n    const ctx = canvas.getContext(\"2d\");\n\n    var gradient = ctx.createLinearGradient(0, 0, 100, 100);\n    gradient.addColorStop(0.0, \"red\");\n    gradient.addColorStop(1 / 6, \"orange\");\n    gradient.addColorStop(2 / 6, \"yellow\");\n    gradient.addColorStop(3 / 6, \"green\");\n    gradient.addColorStop(4 / 6, \"aqua\");\n    gradient.addColorStop(5 / 6, \"blue\");\n    gradient.addColorStop(1.0, \"purple\");\n\n    const errMsg = this.state.errMsg;\n    let errDisplay;\n    if (errMsg !== \"\") {\n      errDisplay = (\n        <div className=\"errMsginner\">\n          <span style={{ color: \"white\" }}>\n            {errMsg !== \"\" ? errMsg : null}\n          </span>\n        </div>\n      );\n    } else {\n    }\n\n    const countryOptions = [\n      { key: \"1\", value: \"Machine Learning\", text: \"Machine Learning\" },\n      { key: \"2\", value: \"Computer Science\", text: \"Computer Science\" },\n      {\n        key: \"3\",\n        value: \"Software Engineering\",\n        text: \"Software Engineering\"\n      },\n      { key: \"12\", value: \"Technology\", text: \"Technology\" },\n      { key: \"4\", value: \"Engineering\", text: \"Engineering\" },\n\n      {\n        key: \"6\",\n        value: \"Sciences and Mathematics\",\n        text: \"Sciences and Mathematics\"\n      },\n      {\n        key: \"7\",\n        value: \"Law, Economics and Social Sciences\",\n        text: \"Law, Economics and Social Sciences\"\n      },\n      { key: \"8\", value: \"Humanities\", text: \"Humanities\" },\n      {\n        key: \"9\",\n        value: \"Linguistics and Cultural Studies\",\n        text: \"Linguistics and Cultural Studies\"\n      },\n      { key: \"10\", value: \"Art and Music\", text: \"Art and Music\" },\n      { key: \"11\", value: \"Lifestyle\", text: \"Lifestyle\" },\n      {\n        key: \"13\",\n        value: \"Others\",\n        text: \"Others\"\n      }\n    ];\n\n    return (\n      <React.Fragment>\n        <div\n          onKeyDown={event => {\n            const x = 88,\n              deleteKey = 46,\n              copy = 67,\n              paste = 86,\n              z = 90,\n              y = 89;\n\n            if (\n              ((event.ctrlKey && event.keyCode === x) ||\n                event.keyCode === deleteKey) &&\n              !this.state.isPasteDisabled\n            ) {\n              if (this.state.selectedShapeName !== \"\") {\n                var that = this;\n                //delete it from the state too\n                let name = this.state.selectedShapeName;\n                let rectDeleted = false,\n                  ellipseDeleted = false,\n                  starDeleted = false,\n                  arrowDeleted = false,\n                  textDeleted = false;\n\n                var rects = this.state.rectangles.filter(function(eachRect) {\n                  if (eachRect.name === name) {\n                    that.setState({\n                      rectDeleteCount: that.state.rectDeleteCount + 1\n                    });\n                  }\n                  return eachRect.name !== name;\n                });\n\n                var ellipses = this.state.ellipses.filter(function(eachRect) {\n                  if (eachRect.name === name) {\n                    that.setState({\n                      ellipseDeleteCount: that.state.ellipseDeleteCount + 1\n                    });\n                  }\n                  return eachRect.name !== name;\n                });\n\n                var stars = this.state.stars.filter(function(eachRect) {\n                  if (eachRect.name === name) {\n                    that.setState({\n                      starDeleteCount: that.state.starDeleteCount + 1\n                    });\n                  }\n                  return eachRect.name !== name;\n                });\n\n                var arrows = this.state.arrows.filter(function(eachRect) {\n                  if (eachRect.name === name) {\n                    that.setState({\n                      arrowDeleteCount: that.state.arrowDeleteCount + 1\n                    });\n                  }\n                  return eachRect.name !== name;\n                });\n\n                var texts = this.state.texts.filter(function(eachRect) {\n                  if (eachRect.name === name) {\n                    that.setState({\n                      textDeleteCount: that.state.textDeleteCount + 1\n                    });\n                  }\n                  return eachRect.name !== name;\n                });\n\n                this.setState({\n                  rectangles: rects,\n                  ellipses: ellipses,\n                  stars: stars,\n                  arrows: arrows,\n                  texts: texts,\n                  selectedShapeName: \"\"\n                });\n              }\n            } else if (event.shiftKey && event.ctrlKey && event.keyCode === z) {\n              this.handleRedo();\n            } else if (event.ctrlKey && event.keyCode === z) {\n              this.handleUndo();\n            } else if (event.ctrlKey && event.keyCode === y) {\n              this.handleRedo();\n            } else if (event.ctrlKey && event.keyCode === copy) {\n              if (this.state.selectedShapeName !== \"\") {\n                //find it\n                let name = this.state.selectedShapeName;\n                let copiedElement = null;\n                if (name.includes(\"rect\")) {\n                  copiedElement = this.state.rectangles.filter(function(\n                    eachRect\n                  ) {\n                    return eachRect.name === name;\n                  });\n                } else if (name.includes(\"ellipse\")) {\n                  copiedElement = this.state.ellipses.filter(function(\n                    eachRect\n                  ) {\n                    return eachRect.name === name;\n                  });\n                } else if (name.includes(\"star\")) {\n                  copiedElement = this.state.stars.filter(function(eachRect) {\n                    return eachRect.name === name;\n                  });\n                } else if (name.includes(\"text\")) {\n                  copiedElement = this.state.texts.filter(function(eachRect) {\n                    return eachRect.name === name;\n                  });\n                } else if (name.includes(\"arrow\")) {\n                  copiedElement = this.state.arrows.filter(function(eachRect) {\n                    return eachRect.name === name;\n                  });\n                }\n\n                this.setState({ copiedElement: copiedElement }, () => {\n                  console.log(\"copied ele\", this.state.copiedElement);\n                });\n              }\n            } else if (\n              event.ctrlKey &&\n              event.keyCode === paste &&\n              !this.state.isPasteDisabled\n            ) {\n              let copiedElement = this.state.copiedElement[0];\n              console.log(copiedElement);\n              var length;\n              if (copiedElement) {\n                if (copiedElement.attrs) {\n                } else {\n                  if (copiedElement.name.includes(\"rectangle\")) {\n                    length =\n                      this.state.rectangles.length +\n                      1 +\n                      this.state.rectDeleteCount;\n                    var toPush = {\n                      x: copiedElement.x + 10,\n                      y: copiedElement.y + 10,\n                      width: copiedElement.width,\n                      height: copiedElement.height,\n                      stroke: copiedElement.stroke,\n                      strokeWidth: copiedElement.strokeWidth,\n                      name:\n                        \"rectangle\" +\n                        (this.state.rectangles.length +\n                          this.state.rectDeleteCount +\n                          1),\n                      ref:\n                        \"rectangle\" +\n                        (this.state.rectangles.length +\n                          this.state.rectDeleteCount +\n                          1),\n                      fill: copiedElement.fill,\n                      useImage: copiedElement.useImage,\n                      link: copiedElement.link,\n                      rotation: copiedElement.rotation\n                    };\n                    let newName = this.state.selectedShapeName;\n\n                    this.setState(\n                      prevState => ({\n                        rectangles: [...prevState.rectangles, toPush]\n                      }),\n                      () => {\n                        this.setState({\n                          selectedShapeName:\n                            \"rectangle\" + this.state.rectangles.length\n                        });\n                      }\n                    );\n                  } else if (copiedElement.name.includes(\"arrow\")) {\n                    length =\n                      this.state.arrows.length +\n                      1 +\n                      this.state.arrowDeleteCount;\n\n                    if (copiedElement.to || copiedElement.from) {\n                      this.setState(\n                        {\n                          errMsg: \"Connectors cannot be pasted\"\n                        },\n                        () => {\n                          var that = this;\n                          setTimeout(function() {\n                            that.setState({\n                              errMsg: \"\"\n                            });\n                          }, 1000);\n                        }\n                      );\n                    } else {\n                      var toPush = {\n                        points: [\n                          copiedElement.points[0] + 30,\n                          copiedElement.points[1] + 30,\n                          copiedElement.points[2] + 30,\n                          copiedElement.points[3] + 30\n                        ],\n                        fill: copiedElement.fill,\n                        link: copiedElement.link,\n                        stroke: copiedElement.stroke,\n                        strokeWidth: copiedElement.strokeWidth,\n                        name:\n                          \"arrow\" +\n                          (this.state.arrows.length +\n                            1 +\n                            this.state.arrowDeleteCount),\n                        ref:\n                          \"arrow\" +\n                          (this.state.arrows.length +\n                            1 +\n                            this.state.arrowDeleteCount),\n                        rotation: copiedElement.rotation\n                      };\n\n                      let newName = this.state.selectedShapeName;\n\n                      this.setState(\n                        prevState => ({\n                          arrows: [...prevState.arrows, toPush]\n                        }),\n                        () => {\n                          this.setState({\n                            selectedShapeName:\n                              \"arrow\" + this.state.arrows.length\n                          });\n                        }\n                      );\n                    }\n                  } else if (copiedElement.name.includes(\"ellipse\")) {\n                    length =\n                      this.state.ellipses.length +\n                      1 +\n                      this.state.ellipseDeleteCount;\n                    var toPush = {\n                      x: copiedElement.x + 10,\n                      y: copiedElement.y + 10,\n                      radiusX: copiedElement.radiusX,\n                      radiusY: copiedElement.radiusY,\n                      stroke: copiedElement.stroke,\n                      strokeWidth: copiedElement.strokeWidth,\n                      name:\n                        \"ellipse\" +\n                        (this.state.ellipses.length +\n                          1 +\n                          this.state.ellipseDeleteCount),\n                      ref:\n                        \"ellipse\" +\n                        (this.state.ellipses.length +\n                          1 +\n                          this.state.ellipseDeleteCount),\n                      fill: copiedElement.fill,\n                      link: copiedElement.link,\n                      useImage: copiedElement.useImage,\n                      rotation: copiedElement.rotation\n                    };\n                    let newName = this.state.selectedShapeName;\n\n                    this.setState(\n                      prevState => ({\n                        ellipses: [...prevState.ellipses, toPush]\n                      }),\n                      () => {\n                        this.setState({\n                          selectedShapeName:\n                            \"ellipse\" + this.state.ellipses.length\n                        });\n                      }\n                    );\n                  } else if (copiedElement.name.includes(\"star\")) {\n                    length =\n                      this.state.stars.length + 1 + this.state.starDeleteCount;\n                    var toPush = {\n                      x: copiedElement.x + 10,\n                      y: copiedElement.y + 10,\n                      link: copiedElement.link,\n                      innerRadius: copiedElement.innerRadius,\n                      outerRadius: copiedElement.outerRadius,\n                      stroke: copiedElement.stroke,\n                      strokeWidth: copiedElement.strokeWidth,\n                      name:\n                        \"star\" +\n                        (this.state.stars.length +\n                          1 +\n                          this.state.starDeleteCount),\n                      ref:\n                        \"star\" +\n                        (this.state.stars.length +\n                          1 +\n                          this.state.starDeleteCount),\n                      fill: copiedElement.fill,\n                      useImage: copiedElement.useImage,\n                      rotation: copiedElement.rotation\n                    };\n                    let newName = this.state.selectedShapeName;\n\n                    this.setState(\n                      prevState => ({\n                        stars: [...prevState.stars, toPush]\n                      }),\n                      () => {\n                        this.setState({\n                          selectedShapeName: \"star\" + this.state.stars.length\n                        });\n                      }\n                    );\n                  } else if (copiedElement.name.includes(\"text\")) {\n                    length =\n                      this.state.texts.length + 1 + this.state.textDeleteCount;\n                    var toPush = {\n                      x: copiedElement.x + 10,\n                      y: copiedElement.y + 10,\n                      link: copiedElement.link,\n\n                      name:\n                        \"text\" +\n                        (this.state.texts.length +\n                          1 +\n                          this.state.textDeleteCount),\n                      ref:\n                        \"text\" +\n                        (this.state.texts.length +\n                          1 +\n                          this.state.textDeleteCount),\n                      fill: copiedElement.fill,\n                      fontSize: copiedElement.fontSize,\n                      fontFamily: copiedElement.fontFamily,\n                      useImage: copiedElement.useImage,\n                      text: copiedElement.text,\n                      width: copiedElement.width,\n                      rotation: copiedElement.rotation\n                    };\n                    let newName = this.state.selectedShapeName;\n\n                    this.setState(\n                      prevState => ({\n                        texts: [...prevState.texts, toPush]\n                      }),\n                      () => {\n                        this.setState(\n                          {\n                            selectedShapeName:\n                              \"text\" +\n                              (this.state.texts.length +\n                                this.state.textDeleteCount)\n                          },\n                          () => {\n                            console.log(this.state.selectedShapeName);\n                          }\n                        );\n                      }\n                    );\n                  }\n                }\n              }\n            }\n          }}\n          tabIndex=\"0\"\n          style={{ outline: \"none\" }}\n        >\n          <Stage\n            onClick={this.handleStageClick}\n            onMouseMove={this.handleMouseOver}\n            onWheel={event => this.handleWheel(event)}\n            height={window.innerHeight}\n            width={window.innerWidth}\n            ref=\"graphicStage\"\n          >\n            <Layer\n              scaleX={this.state.layerScale}\n              scaleY={this.state.layerScale}\n              x={this.state.layerX}\n              y={this.state.layerY}\n              height={window.innerHeight}\n              width={window.innerWidth}\n              draggable\n              onDragEnd={() => {\n                this.setState({\n                  layerX: this.refs.layer2.x(),\n                  layerY: this.refs.layer2.y()\n                });\n              }}\n              ref=\"layer2\"\n            >\n              <Rect\n                x={-5 * window.innerWidth}\n                y={-5 * window.innerHeight}\n                height={window.innerHeight * 10}\n                width={window.innerWidth * 10}\n                name=\"\"\n                id=\"ContainerRect\"\n              />\n\n              {this.state.rectangles.map(eachRect => {\n                return (\n                  <Rect\n                    onClick={() => {\n                      var that = this;\n                      if (eachRect.link !== undefined && eachRect.link !== \"\") {\n                        this.setState(\n                          {\n                            errMsg: \"Links will not be opened in create mode\"\n                          },\n                          () => {\n                            setTimeout(function() {\n                              that.setState({\n                                errMsg: \"\"\n                              });\n                            }, 1000);\n                          }\n                        );\n                      }\n                    }}\n                    onTransformStart={() => {\n                      this.setState({\n                        isTransforming: true\n                      });\n                      let rect = this.refs[eachRect.ref];\n                      rect.setAttr(\"lastRotation\", rect.rotation());\n                    }}\n                    onTransform={() => {\n                      let rect = this.refs[eachRect.ref];\n\n                      if (rect.attrs.lastRotation !== rect.rotation()) {\n                        this.state.arrows.map(eachArrow => {\n                          if (\n                            eachArrow.to &&\n                            eachArrow.to.name() === rect.name()\n                          ) {\n                            this.setState({\n                              errMsg:\n                                \"Rotating rects with connectors might skew things up!\"\n                            });\n                          }\n                          if (\n                            eachArrow.from &&\n                            eachArrow.from.name() === rect.name()\n                          ) {\n                            this.setState({\n                              errMsg:\n                                \"Rotating rects with connectors might skew things up!\"\n                            });\n                          }\n                        });\n                      }\n\n                      rect.setAttr(\"lastRotation\", rect.rotation());\n                    }}\n                    onTransformEnd={() => {\n                      this.setState({\n                        isTransforming: false\n                      });\n                      let rect = this.refs[eachRect.ref];\n                      this.setState(\n                        prevState => ({\n                          errMsg: \"\",\n                          rectangles: prevState.rectangles.map(eachRect =>\n                            eachRect.name === rect.attrs.name\n                              ? {\n                                  ...eachRect,\n                                  width: rect.width() * rect.scaleX(),\n                                  height: rect.height() * rect.scaleY(),\n                                  rotation: rect.rotation(),\n                                  x: rect.x(),\n                                  y: rect.y()\n                                }\n                              : eachRect\n                          )\n                        }),\n                        () => {\n                          this.forceUpdate();\n                        }\n                      );\n\n                      rect.setAttr(\"scaleX\", 1);\n                      rect.setAttr(\"scaleY\", 1);\n                    }}\n                    rotation={eachRect.rotation}\n                    ref={eachRect.ref}\n                    fill={eachRect.fill}\n                    name={eachRect.name}\n                    x={eachRect.x}\n                    y={eachRect.y}\n                    width={eachRect.width}\n                    height={eachRect.height}\n                    stroke={eachRect.stroke}\n                    strokeWidth={eachRect.strokeWidth}\n                    strokeScaleEnabled={false}\n                    draggable\n                    onDragMove={() => {\n                      this.state.arrows.map(eachArrow => {\n                        if (eachArrow.from !== undefined) {\n                          if (eachRect.name === eachArrow.from.attrs.name) {\n                            eachArrow.points = [\n                              eachRect.x,\n                              eachRect.y,\n                              eachArrow.points[2],\n                              eachArrow.points[3]\n                            ];\n                            this.forceUpdate();\n                          }\n                        }\n\n                        if (eachArrow.to !== undefined) {\n                          if (eachRect.name == eachArrow.to.attrs.name) {\n                            eachArrow.points = [\n                              eachArrow.points[0],\n                              eachArrow.points[1],\n                              eachRect.x,\n                              eachRect.y\n                            ];\n                            this.forceUpdate();\n                          }\n                        }\n                      });\n                    }}\n                    onDragEnd={event => {\n                      //cannot compare by name because currentSelected might not be the same\n                      //have to use ref, which appears to be overcomplicated\n                      var shape = this.refs[eachRect.ref];\n                      /*    this.state.rectangles.map(eachRect => {\n                          if (eachRect.name === shape.attrs.name) {\n                            shape.position({\n                              x: event.target.x(),\n                              y: event.target.y()\n                            });\n                          }\n                        });*/\n\n                      this.setState(prevState => ({\n                        rectangles: prevState.rectangles.map(eachRect =>\n                          eachRect.name === shape.attrs.name\n                            ? {\n                                ...eachRect,\n                                x: event.target.x(),\n                                y: event.target.y()\n                              }\n                            : eachRect\n                        )\n                      }));\n                    }}\n                  />\n                );\n              })}\n              {this.state.ellipses.map(eachEllipse => (\n                <Ellipse\n                  ref={eachEllipse.ref}\n                  name={eachEllipse.name}\n                  x={eachEllipse.x}\n                  y={eachEllipse.y}\n                  rotation={eachEllipse.rotation}\n                  radiusX={eachEllipse.radiusX}\n                  radiusY={eachEllipse.radiusY}\n                  fill={eachEllipse.fill}\n                  stroke={eachEllipse.stroke}\n                  strokeWidth={eachEllipse.strokeWidth}\n                  strokeScaleEnabled={false}\n                  onClick={() => {\n                    var that = this;\n                    if (\n                      eachEllipse.link !== undefined &&\n                      eachEllipse.link !== \"\"\n                    ) {\n                      this.setState(\n                        {\n                          errMsg: \"Links will not be opened in create mode\"\n                        },\n                        () => {\n                          setTimeout(function() {\n                            that.setState({\n                              errMsg: \"\"\n                            });\n                          }, 1000);\n                        }\n                      );\n                    }\n                  }}\n                  onTransformStart={() => {\n                    this.setState({ isTransforming: true });\n                    let ellipse = this.refs[eachEllipse.ref];\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\n                  }}\n                  onTransform={() => {\n                    let ellipse = this.refs[eachEllipse.ref];\n\n                    if (ellipse.attrs.lastRotation !== ellipse.rotation()) {\n                      this.state.arrows.map(eachArrow => {\n                        if (\n                          eachArrow.to &&\n                          eachArrow.to.name() === ellipse.name()\n                        ) {\n                          this.setState({\n                            errMsg:\n                              \"Rotating ellipses with connectors might skew things up!\"\n                          });\n                        }\n                        if (\n                          eachArrow.from &&\n                          eachArrow.from.name() === ellipse.name()\n                        ) {\n                          this.setState({\n                            errMsg:\n                              \"Rotating ellipses with connectors might skew things up!\"\n                          });\n                        }\n                      });\n                    }\n\n                    ellipse.setAttr(\"lastRotation\", ellipse.rotation());\n                  }}\n                  onTransformEnd={() => {\n                    this.setState({ isTransforming: false });\n                    let ellipse = this.refs[eachEllipse.ref];\n                    let scaleX = ellipse.scaleX(),\n                      scaleY = ellipse.scaleY();\n\n                    this.setState(prevState => ({\n                      errMsg: \"\",\n                      ellipses: prevState.ellipses.map(eachEllipse =>\n                        eachEllipse.name === ellipse.attrs.name\n                          ? {\n                              ...eachEllipse,\n\n                              radiusX: ellipse.radiusX() * ellipse.scaleX(),\n                              radiusY: ellipse.radiusY() * ellipse.scaleY(),\n                              rotation: ellipse.rotation(),\n                              x: ellipse.x(),\n                              y: ellipse.y()\n                            }\n                          : eachEllipse\n                      )\n                    }));\n\n                    ellipse.setAttr(\"scaleX\", 1);\n                    ellipse.setAttr(\"scaleY\", 1);\n                    this.forceUpdate();\n                  }}\n                  draggable\n                  onDragMove={() => {\n                    console.log(\n                      \"name of ellipse moving: \",\n                      eachEllipse.name,\n                      \"new x y\",\n                      eachEllipse.x,\n                      eachEllipse.y\n                    );\n                    this.state.arrows.map(eachArrow => {\n                      if (eachArrow.from !== undefined) {\n                        console.log(\"prevArrow: \", eachArrow.points);\n                        if (eachEllipse.name == eachArrow.from.attrs.name) {\n                          eachArrow.points = [\n                            eachEllipse.x,\n                            eachEllipse.y,\n                            eachArrow.points[2],\n                            eachArrow.points[3]\n                          ];\n                          this.forceUpdate();\n                          this.refs.graphicStage.draw();\n                        }\n                        console.log(\"new arrows:\", eachArrow.points);\n                      }\n\n                      if (eachArrow.to !== undefined) {\n                        if (eachEllipse.name === eachArrow.to.attrs.name) {\n                          eachArrow.points = [\n                            eachArrow.points[0],\n                            eachArrow.points[1],\n                            eachEllipse.x,\n                            eachEllipse.y\n                          ];\n                          this.forceUpdate();\n                          this.refs.graphicStage.draw();\n                        }\n                      }\n                    });\n                  }}\n                  onDragEnd={event => {\n                    //cannot compare by name because currentSelected might not be the same\n                    //have to use ref, which appears to be overcomplicated\n                    var shape = this.refs[eachEllipse.ref];\n\n                    this.setState(prevState => ({\n                      ellipses: prevState.ellipses.map(eachEllipse =>\n                        eachEllipse.name === shape.attrs.name\n                          ? {\n                              ...eachEllipse,\n                              x: event.target.x(),\n                              y: event.target.y()\n                            }\n                          : eachEllipse\n                      )\n                    }));\n\n                    this.refs.graphicStage.draw();\n                  }}\n                />\n              ))}\n              {this.state.stars.map(eachStar => (\n                <Star\n                  ref={eachStar.ref}\n                  name={eachStar.name}\n                  x={eachStar.x}\n                  y={eachStar.y}\n                  innerRadius={eachStar.innerRadius}\n                  outerRadius={eachStar.outerRadius}\n                  numPoints={eachStar.numPoints}\n                  stroke={eachStar.stroke}\n                  strokeWidth={eachStar.strokeWidth}\n                  fill={eachStar.fill}\n                  strokeScaleEnabled={false}\n                  rotation={eachStar.rotation}\n                  onClick={() => {\n                    var that = this;\n                    if (eachStar.link !== undefined && eachStar.link !== \"\") {\n                      this.setState(\n                        {\n                          errMsg: \"Links will not be opened in create mode\"\n                        },\n                        () => {\n                          setTimeout(function() {\n                            that.setState({\n                              errMsg: \"\"\n                            });\n                          }, 1000);\n                        }\n                      );\n                    }\n                  }}\n                  onTransformStart={() => {\n                    this.setState({ isTransforming: true });\n                  }}\n                  onTransformEnd={() => {\n                    this.setState({ isTransforming: false });\n                    let star = this.refs[eachStar.ref];\n                    let scaleX = star.scaleX(),\n                      scaleY = star.scaleY();\n\n                    this.setState(prevState => ({\n                      stars: prevState.stars.map(eachStar =>\n                        eachStar.name === star.attrs.name\n                          ? {\n                              ...eachStar,\n                              innerRadius: star.innerRadius() * star.scaleX(),\n                              outerRadius: star.outerRadius() * star.scaleX(),\n                              rotation: star.rotation(),\n                              x: star.x(),\n                              y: star.y()\n                            }\n                          : eachStar\n                      )\n                    }));\n                    star.setAttr(\"scaleX\", 1);\n                    star.setAttr(\"scaleY\", 1);\n                    this.forceUpdate();\n                  }}\n                  draggable\n                  onDragMove={() => {\n                    this.state.arrows.map(eachArrow => {\n                      if (eachArrow.from !== undefined) {\n                        if (eachStar.name == eachArrow.from.attrs.name) {\n                          eachArrow.points = [\n                            eachStar.x,\n                            eachStar.y,\n                            eachArrow.points[2],\n                            eachArrow.points[3]\n                          ];\n                          this.forceUpdate();\n                        }\n                      }\n\n                      if (eachArrow.to !== undefined) {\n                        if (eachStar.name === eachArrow.to.attrs.name) {\n                          eachArrow.points = [\n                            eachArrow.points[0],\n                            eachArrow.points[1],\n                            eachStar.x,\n                            eachStar.y\n                          ];\n                          this.forceUpdate();\n                        }\n                      }\n                    });\n                  }}\n                  onDragEnd={event => {\n                    //cannot compare by name because currentSelected might not be the same\n                    //have to use ref, which appears to be overcomplicated\n                    var shape = this.refs[eachStar.ref];\n\n                    this.setState(prevState => ({\n                      stars: prevState.stars.map(eachStar =>\n                        eachStar.name === shape.attrs.name\n                          ? {\n                              ...eachStar,\n                              x: event.target.x(),\n                              y: event.target.y()\n                            }\n                          : eachStar\n                      )\n                    }));\n                  }}\n                />\n              ))}\n              {this.state.texts.map(eachText => (\n                //perhaps this.state.texts only need to contain refs?\n                //so that we only need to store the refs to get more information\n                <Text\n                  textDecoration={eachText.link ? \"underline\" : \"\"}\n                  onTransformStart={() => {\n                    var currentText = this.refs[this.state.selectedShapeName];\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\n                  }}\n                  onTransform={() => {\n                    var currentText = this.refs[this.state.selectedShapeName];\n\n                    currentText.setAttr(\n                      \"width\",\n                      currentText.width() * currentText.scaleX()\n                    );\n                    currentText.setAttr(\"scaleX\", 1);\n\n                    currentText.draw();\n\n                    if (\n                      currentText.attrs.lastRotation !== currentText.rotation()\n                    ) {\n                      this.state.arrows.map(eachArrow => {\n                        if (\n                          eachArrow.to &&\n                          eachArrow.to.name() === currentText.name()\n                        ) {\n                          this.setState({\n                            errMsg:\n                              \"Rotating texts with connectors might skew things up!\"\n                          });\n                        }\n                        if (\n                          eachArrow.from &&\n                          eachArrow.from.name() === currentText.name()\n                        ) {\n                          this.setState({\n                            errMsg:\n                              \"Rotating texts with connectors might skew things up!\"\n                          });\n                        }\n                      });\n                    }\n\n                    currentText.setAttr(\"lastRotation\", currentText.rotation());\n                  }}\n                  onTransformEnd={() => {\n                    var currentText = this.refs[this.state.selectedShapeName];\n\n                    this.setState(prevState => ({\n                      errMsg: \"\",\n                      texts: prevState.texts.map(eachText =>\n                        eachText.name === this.state.selectedShapeName\n                          ? {\n                              ...eachText,\n                              width: currentText.width(),\n                              rotation: currentText.rotation(),\n                              textWidth: currentText.textWidth,\n                              textHeight: currentText.textHeight,\n                              x: currentText.x(),\n                              y: currentText.y()\n                            }\n                          : eachText\n                      )\n                    }));\n                    currentText.setAttr(\"scaleX\", 1);\n                    currentText.draw();\n                  }}\n                  link={eachText.link}\n                  width={eachText.width}\n                  fill={eachText.fill}\n                  name={eachText.name}\n                  ref={eachText.ref}\n                  rotation={eachText.rotation}\n                  fontFamily={eachText.fontFamily}\n                  fontSize={eachText.fontSize}\n                  x={eachText.x}\n                  y={eachText.y}\n                  text={eachText.text}\n                  draggable\n                  onDragMove={() => {\n                    this.state.arrows.map(eachArrow => {\n                      if (eachArrow.from !== undefined) {\n                        if (eachText.name === eachArrow.from.attrs.name) {\n                          eachArrow.points = [\n                            eachText.x,\n                            eachText.y,\n                            eachArrow.points[2],\n                            eachArrow.points[3]\n                          ];\n                          this.forceUpdate();\n                        }\n                      }\n\n                      if (eachArrow.to !== undefined) {\n                        if (eachText.name === eachArrow.to.attrs.name) {\n                          eachArrow.points = [\n                            eachArrow.points[0],\n                            eachArrow.points[1],\n                            eachText.x,\n                            eachText.y\n                          ];\n                          this.forceUpdate();\n                        }\n                      }\n                    });\n                  }}\n                  onDragEnd={event => {\n                    //cannot compare by name because currentSelected might not be the same\n                    //have to use ref, which appears to be overcomplicated\n                    var shape = this.refs[eachText.ref];\n\n                    this.setState(prevState => ({\n                      texts: prevState.texts.map(eachtext =>\n                        eachtext.name === shape.attrs.name\n                          ? {\n                              ...eachtext,\n                              x: event.target.x(),\n                              y: event.target.y()\n                            }\n                          : eachtext\n                      )\n                    }));\n                  }}\n                  onClick={() => {\n                    var that = this;\n                    if (eachText.link !== undefined && eachText.link !== \"\") {\n                      this.setState(\n                        {\n                          errMsg: \"Links will not be opened in create mode\"\n                        },\n                        () => {\n                          setTimeout(function() {\n                            that.setState({\n                              errMsg: \"\"\n                            });\n                          }, 1000);\n                        }\n                      );\n\n                      //var win = window.open(eachText.link, \"_blank\");\n                      //win.focus();\n                    }\n                  }}\n                  onDblClick={() => {\n                    // turn into textarea\n                    var stage = this.refs.graphicStage;\n                    var text = stage.findOne(\".\" + eachText.name);\n\n                    this.setState({\n                      textX: text.absolutePosition().x,\n                      textY: text.absolutePosition().y,\n                      textEditVisible: !this.state.textEditVisible,\n                      text: eachText.text,\n                      textNode: eachText,\n                      currentTextRef: eachText.ref,\n                      textareaWidth: text.textWidth,\n                      textareaHeight: text.textHeight,\n                      textareaFill: text.attrs.fill,\n                      textareaFontFamily: text.attrs.fontFamily,\n                      textareaFontSize: text.attrs.fontSize\n                    });\n                    let textarea = this.refs.textarea;\n                    textarea.focus();\n                    text.hide();\n                    var transformer = stage.findOne(\".transformer\");\n                    transformer.hide();\n                    this.refs.layer2.draw();\n                  }}\n                />\n              ))}\n              {this.state.arrows.map(eachArrow => {\n                if (!eachArrow.from && !eachArrow.to) {\n                  return (\n                    <Arrow\n                      ref={eachArrow.ref}\n                      name={eachArrow.name}\n                      points={[\n                        eachArrow.points[0],\n                        eachArrow.points[1],\n                        eachArrow.points[2],\n                        eachArrow.points[3]\n                      ]}\n                      stroke={eachArrow.stroke}\n                      fill={eachArrow.fill}\n                      draggable\n                      onDragEnd={event => {\n                        //set new points to current position\n\n                        //usually: state => star => x & y\n                        //now: state => arrow => attr => x & y\n\n                        let oldPoints = [\n                          eachArrow.points[0],\n                          eachArrow.points[1],\n                          eachArrow.points[2],\n                          eachArrow.points[3]\n                        ];\n\n                        let shiftX = this.refs[eachArrow.ref].attrs.x;\n                        let shiftY = this.refs[eachArrow.ref].attrs.y;\n\n                        let newPoints = [\n                          oldPoints[0] + shiftX,\n                          oldPoints[1] + shiftY,\n                          oldPoints[2] + shiftX,\n                          oldPoints[3] + shiftY\n                        ];\n\n                        this.refs[eachArrow.ref].position({ x: 0, y: 0 });\n                        this.refs.layer2.draw();\n\n                        this.setState(prevState => ({\n                          arrows: prevState.arrows.map(eachArr =>\n                            eachArr.name === eachArrow.name\n                              ? {\n                                  ...eachArr,\n                                  points: newPoints\n                                }\n                              : eachArr\n                          )\n                        }));\n                      }}\n                    />\n                  );\n                } else if (\n                  eachArrow.name === this.state.newArrowRef &&\n                  (eachArrow.from || eachArrow.to)\n                ) {\n                  return (\n                    <Connector\n                      name={eachArrow.name}\n                      from={eachArrow.from}\n                      to={eachArrow.to}\n                      arrowEndX={this.state.arrowEndX}\n                      arrowEndY={this.state.arrowEndY}\n                      current={true}\n                      stroke={eachArrow.stroke}\n                      fill={eachArrow.fill}\n                    />\n                  );\n                } else if (eachArrow.from || eachArrow.to) {\n                  //if arrow construction is completed\n                  return (\n                    <Connector\n                      name={eachArrow.name}\n                      from={eachArrow.from}\n                      to={eachArrow.to}\n                      points={eachArrow.points}\n                      current={false}\n                      stroke={eachArrow.stroke}\n                      fill={eachArrow.fill}\n                    />\n                  );\n                }\n              })}\n\n              {this.state.selectedShapeName.includes(\"text\") ? (\n                <TransformerComponent\n                  selectedShapeName={this.state.selectedShapeName}\n                />\n              ) : (\n                <TransformerComponent\n                  selectedShapeName={this.state.selectedShapeName}\n                />\n              )}\n            </Layer>\n\n            <Layer\n              height={window.innerHeight}\n              width={window.innerWidth}\n              ref=\"layer\"\n            >\n              <Toolbar\n                layer={this.refs.layer2}\n                rectName={\n                  this.state.rectangles.length + 1 + this.state.rectDeleteCount\n                }\n                ellipseName={\n                  this.state.ellipses.length + 1 + this.state.ellipseDeleteCount\n                }\n                starName={\n                  this.state.stars.length + 1 + this.state.starDeleteCount\n                }\n                textName={\n                  this.state.texts.length + 1 + this.state.textDeleteCount\n                }\n                newArrowOnDragEnd={toPush => {\n                  if (toPush.from !== undefined) {\n                    //  console.log(\"we are making a connector\");\n\n                    var transform = this.refs.layer2\n                      .getAbsoluteTransform()\n                      .copy();\n                    transform.invert();\n                    let uh = transform.point({\n                      x: toPush.x,\n                      y: toPush.y\n                    });\n                    toPush.x = uh.x;\n                    toPush.y = uh.y;\n\n                    var newArrow = {\n                      points: toPush.points,\n                      ref:\n                        \"arrow\" +\n                        (this.state.arrows.length +\n                          1 +\n                          this.state.arrowDeleteCount),\n                      name:\n                        \"arrow\" +\n                        (this.state.arrows.length +\n                          1 +\n                          this.state.arrowDeleteCount),\n                      from: toPush.from,\n                      stroke: toPush.stroke,\n                      strokeWidth: toPush.strokeWidth,\n                      fill: toPush.fill\n                    };\n\n                    //  console.log(newArrow);\n                    this.setState(prevState => ({\n                      arrows: [...prevState.arrows, newArrow],\n                      newArrowDropped: true,\n                      newArrowRef: newArrow.name,\n                      arrowEndX: toPush.x,\n                      arrowEndY: toPush.y\n                    }));\n                  } else {\n                    //  console.log(\"we are making just an aarrow\");\n                    var transform = this.refs.layer2\n                      .getAbsoluteTransform()\n                      .copy();\n                    transform.invert();\n                    let uh = transform.point({\n                      x: toPush.x,\n                      y: toPush.y\n                    });\n                    toPush.x = uh.x;\n                    toPush.y = uh.y;\n                    var newArrow = {\n                      points: [toPush.x, toPush.y, toPush.x, toPush.y],\n                      ref:\n                        \"arrow\" +\n                        (this.state.arrows.length +\n                          1 +\n                          this.state.arrowDeleteCount),\n                      name:\n                        \"arrow\" +\n                        (this.state.arrows.length +\n                          1 +\n                          this.state.arrowDeleteCount),\n                      from: toPush.from,\n                      stroke: toPush.stroke,\n                      strokeWidth: toPush.strokeWidth,\n                      fill: toPush.fill\n                    };\n\n                    this.setState(prevState => ({\n                      arrows: [...prevState.arrows, newArrow],\n                      newArrowDropped: true,\n                      newArrowRef: newArrow.name,\n                      arrowEndX: toPush.x,\n                      arrowEndY: toPush.y\n                    }));\n                  }\n\n                  //this.refs updates after forceUpdate (because arrow gets instantiated), might be risky in the future\n                  //only this.state.arrows.length because it was pushed earlier, cancelling the +1\n                }}\n                appendToRectangles={stuff => {\n                  var layer = this.refs.layer2;\n                  var toPush = stuff;\n                  var stage = this.refs.graphicStage;\n                  var transform = this.refs.layer2\n                    .getAbsoluteTransform()\n                    .copy();\n                  transform.invert();\n\n                  var pos = transform.point({\n                    x: toPush.x,\n                    y: toPush.y\n                  });\n\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n                    toPush.x = pos.x;\n                    toPush.y = pos.y;\n                  }\n\n                  this.setState(prevState => ({\n                    rectangles: [...prevState.rectangles, toPush],\n                    selectedShapeName: toPush.name\n                  }));\n                }}\n                appendToEllipses={stuff => {\n                  var layer = this.refs.layer2;\n                  var toPush = stuff;\n                  var stage = this.refs.graphicStage;\n                  var transform = this.refs.layer2\n                    .getAbsoluteTransform()\n                    .copy();\n                  transform.invert();\n\n                  var pos = transform.point({\n                    x: toPush.x,\n                    y: toPush.y\n                  });\n\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n                    toPush.x = pos.x;\n                    toPush.y = pos.y;\n                  }\n\n                  this.setState(prevState => ({\n                    ellipses: [...prevState.ellipses, toPush],\n                    selectedShapeName: toPush.name\n                  }));\n                }}\n                appendToStars={stuff => {\n                  var layer = this.refs.layer2;\n                  var toPush = stuff;\n                  var stage = this.refs.graphicStage;\n                  var transform = this.refs.layer2\n                    .getAbsoluteTransform()\n                    .copy();\n                  transform.invert();\n\n                  var pos = transform.point({\n                    x: toPush.x,\n                    y: toPush.y\n                  });\n\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n                    toPush.x = pos.x;\n                    toPush.y = pos.y;\n                  }\n                  this.setState(prevState => ({\n                    stars: [...prevState.stars, toPush],\n                    selectedShapeName: toPush.name\n                  }));\n                }}\n                appendToTexts={stuff => {\n                  var layer = this.refs.layer2;\n                  var toPush = stuff;\n                  var stage = this.refs.graphicStage;\n                  var transform = this.refs.layer2\n                    .getAbsoluteTransform()\n                    .copy();\n                  transform.invert();\n\n                  var pos = transform.point({\n                    x: toPush.x,\n                    y: toPush.y\n                  });\n\n                  if (layer.attrs.x !== null || layer.attrs.x !== undefined) {\n                    toPush.x = pos.x;\n                    toPush.y = pos.y;\n                  }\n\n                  this.setState(prevState => ({\n                    texts: [...prevState.texts, toPush]\n                  }));\n\n                  //we can also just get element by this.refs.toPush.ref\n\n                  //  let text = stage.findOne(\".\" + toPush.name);\n                  let text = this.refs[toPush.ref];\n                  //this.setState({firstTimeTextEditing: true});\n                  text.fire(\"dblclick\");\n                }}\n              />\n            </Layer>\n          </Stage>\n\n          <textarea\n            ref=\"textarea\"\n            id=\"textarea\"\n            value={this.state.text}\n            onChange={e => {\n              this.setState({\n                text: e.target.value,\n                shouldTextUpdate: false\n              });\n            }}\n            onKeyDown={e => {\n              if (e.keyCode === 13) {\n                this.setState({\n                  textEditVisible: false,\n                  shouldTextUpdate: true\n                });\n\n                // get the current textNode we are editing, get the name from there\n                //match name with elements in this.state.texts,\n                let node = this.refs[this.state.currentTextRef];\n                console.log(\"node width before set\", node.textWidth);\n                let name = node.attrs.name;\n                this.setState(\n                  prevState => ({\n                    selectedShapeName: name,\n                    texts: prevState.texts.map(eachText =>\n                      eachText.name === name\n                        ? {\n                            ...eachText,\n                            text: this.state.text\n                          }\n                        : eachText\n                    )\n                  }),\n                  () => {\n                    this.setState(prevState => ({\n                      texts: prevState.texts.map(eachText =>\n                        eachText.name === name\n                          ? {\n                              ...eachText,\n                              textWidth: node.textWidth,\n                              textHeight: node.textHeight\n                            }\n                          : eachText\n                      )\n                    }));\n                  }\n                );\n\n                node.show();\n                this.refs.graphicStage.findOne(\".transformer\").show();\n              }\n            }}\n            onBlur={() => {\n              this.setState({\n                textEditVisible: false,\n                shouldTextUpdate: true\n              });\n\n              // get the current textNode we are editing, get the name from there\n              //match name with elements in this.state.texts,\n\n              let node = this.refs.graphicStage.findOne(\n                \".\" + this.state.currentTextRef\n              );\n              let name = node.attrs.name;\n\n              this.setState(\n                prevState => ({\n                  selectedShapeName: name,\n                  texts: prevState.texts.map(eachText =>\n                    eachText.name === name\n                      ? {\n                          ...eachText,\n                          text: this.state.text\n                        }\n                      : eachText\n                  )\n                }),\n                () => {\n                  this.setState(prevState => ({\n                    texts: prevState.texts.map(eachText =>\n                      eachText.name === name\n                        ? {\n                            ...eachText,\n                            textWidth: node.textWidth,\n                            textHeight: node.textHeight\n                          }\n                        : eachText\n                    )\n                  }));\n                }\n              );\n              node.show();\n              this.refs.graphicStage.findOne(\".transformer\").show();\n              this.refs.graphicStage.draw();\n            }}\n            style={{\n              //set position, width, height, fontSize, overflow, lineHeight, color\n              display: this.state.textEditVisible ? \"block\" : \"none\",\n              position: \"absolute\",\n              top: this.state.textY + 80 + \"px\",\n              left: this.state.textX + \"px\",\n              width: \"300px\",\n              height: \"300px\",\n              overflow: \"hidden\",\n              fontSize: this.state.textareaFontSize,\n              fontFamily: this.state.textareaFontFamily,\n              color: this.state.textareaFill,\n              border: \"none\",\n              padding: \"0px\",\n              margin: \"0px\",\n              outline: \"none\",\n              resize: \"none\",\n              background: \"none\"\n            }}\n          />\n          <div className=\"errMsg\">{errDisplay}</div>\n        </div>\n      </React.Fragment>\n    );\n  }\n}\nconst mapStateToProps = state => ({\n  auth: state.auth\n});\n\nexport default Graphics;\n","import React from \"react\";\nimport ReactDOM from \"react-dom\";\nimport { CSSTransition } from \"react-transition-group\";\n\nimport \"./styles.css\";\nimport ColoredRect from \"./App.js\";\n\nclass FadeInAndOut extends React.Component {\n  constructor(...args) {\n    super(...args);\n    this.state = { show: false };\n\n    setInterval(() => {\n      this.setState({ show: !this.state.show });\n    }, 2000);\n  }\n\n  render() {\n    return (\n      <div>\n        <a\n          onClick={() => {\n            this.setState({ show: !this.state.show });\n          }}\n          style={{ cursor: \"pointer\", padding: \"20px\" }}\n        >\n          Woah\n        </a>\n        <CSSTransition in={this.state.show} timeout={1200} classNames=\"base\">\n          <div>Hello World</div>\n        </CSSTransition>\n      </div>\n    );\n  }\n}\n\nReactDOM.render(<ColoredRect />, document.getElementById(\"root\"));\n"],"sourceRoot":""}